name: Plugin release (GitHub)

on:
  workflow_call:
    inputs:
      plugin_slug:
        type: string
        required: false
        description: "Plugin slug for zip filename. Defaults to repository name."
      readme_path:
        type: string
        required: false
        default: "readme.md"
      version_heading_regex:
        type: string
        required: false
        default: "^###\\s+{VERSION}\\b.*$"
      tag_prefix:
        type: string
        required: false
        default: "v"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract release notes from README
        shell: bash
        env:
          TAG: ${{ github.ref_name }}
          README_PATH: ${{ inputs.readme_path }}
          HEADING_RE: ${{ inputs.version_heading_regex }}
          TAG_PREFIX: ${{ inputs.tag_prefix }}
        run: |
          set -euo pipefail

          if [ ! -f "$README_PATH" ]; then
            echo "Missing file: ${README_PATH}" >&2
            exit 1
          fi

          python - <<'PY'
          import os, re, sys, pathlib

          tag = os.environ["TAG"]
          prefix = os.environ.get("TAG_PREFIX", "v")
          ver = tag[len(prefix):] if tag.startswith(prefix) else tag
          readme_path = pathlib.Path(os.environ["README_PATH"])
          heading_re = os.environ["HEADING_RE"].replace("{VERSION}", re.escape(ver))

          print(f"Tag: {tag}, Prefix: {prefix}, Version: {ver}")
          print(f"Heading regex: {heading_re}")

          text = readme_path.read_text(encoding="utf-8")

          # find section under the version heading until next same-level heading
          pat = re.compile(rf"{heading_re}\n(.*?)(?=^\s*###\s+|\Z)", re.M | re.S)
          m = pat.search(text)

          if not m:
            print(f"ERROR: Could not find changelog section for version {ver} in {readme_path}", file=sys.stderr)
            print(f"Pattern used: {pat.pattern}", file=sys.stderr)
            sys.exit(1)

          notes = m.group(1).strip()
          if not notes:
            print(f"WARNING: Matched heading but content is empty", file=sys.stderr)

          out = pathlib.Path("release-notes.md")
          out.write_text(notes + "\n", encoding="utf-8")
          print(f"Wrote {out} ({len(notes)} chars)")
          PY

      - name: Resolve plugin slug
        run: |
          if [ -n "${{ inputs.plugin_slug }}" ]; then
            echo "SLUG=${{ inputs.plugin_slug }}" >> "$GITHUB_ENV"
          else
            echo "SLUG=${{ github.event.repository.name }}" >> "$GITHUB_ENV"
          fi

      - name: Build plugin zip
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          PREFIX="${{ inputs.tag_prefix }}"
          VER="${TAG#${PREFIX}}"

          BUILD_DIR="${RUNNER_TEMP}/build"
          mkdir -p "$BUILD_DIR/${SLUG}"

          # Use .distignore if present, otherwise include everything
          if [ -f .distignore ]; then
            rsync -av --exclude-from=.distignore ./ "$BUILD_DIR/${SLUG}/"
          else
            rsync -av --exclude='.git' --exclude='.github' ./ "$BUILD_DIR/${SLUG}/"
          fi

          cd "$BUILD_DIR"
          zip -r "${GITHUB_WORKSPACE}/${SLUG}.zip" "${SLUG}"
          echo "Built ${SLUG}.zip"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          body_path: release-notes.md
          generate_release_notes: true
          files: ${{ env.SLUG }}.zip